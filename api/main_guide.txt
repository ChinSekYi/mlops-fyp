"""
Fraud Detection API with database logging for monitoring and external access.
"""

import json
import logging
import os
from datetime import datetime
from typing import Optional

import mlflow
import pandas as pd
import psycopg2
from fastapi import FastAPI, HTTPException
from mlflow import MlflowClient
from psycopg2.extras import RealDictCursor
from pydantic import BaseModel, Field

from src.utils import load_environment

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

env_file = os.getenv("ENV_FILE", ".env")
load_environment(env_file)

MODEL_NAME = os.getenv("REGISTERED_MODEL_NAME")
MODEL_ALIAS = os.getenv("MODEL_ALIAS")
MLFLOW_TRACKING_URI = os.getenv("MLFLOW_TRACKING_URI")
DATABASE_URL = os.getenv("DATABASE_URL")

mlflow.set_tracking_uri(MLFLOW_TRACKING_URI)
app = FastAPI(title="Fraud Detection API", version="1.0")


class DatabaseLogger:
    """Handles database connections and logging predictions."""

    def __init__(self, database_url: str):
        self.database_url = database_url
        self.connection = None

    def connect(self):
        """Establish database connection."""
        if not self.database_url:
            return

        try:
            self.connection = psycopg2.connect(self.database_url)
            logger.info("Database connection established")
        except Exception as e:
            logger.error(f"Database connection failed: {e}")
            self.connection = None

    def log_prediction(
        self,
        transaction_data: dict,
        prediction: int,
        prediction_proba: float,
        model_info: dict,
    ):
        """Log prediction to database."""
        if not self.connection:
            return

        try:
            cursor = self.connection.cursor()

            insert_query = """
                INSERT INTO predictions (
                    step, amount, oldbalanceOrg, newbalanceOrig, 
                    oldbalanceDest, newbalanceDest, type, 
                    nameOrig_token, nameDest_token,
                    prediction, prediction_probability,
                    model_name, model_version, model_alias
                ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            """

            cursor.execute(
                insert_query,
                (
                    transaction_data["step"],
                    transaction_data["amount"],
                    transaction_data["oldbalanceOrg"],
                    transaction_data["newbalanceOrig"],
                    transaction_data["oldbalanceDest"],
                    transaction_data["newbalanceDest"],
                    transaction_data["type"],
                    transaction_data["nameOrig_token"],
                    transaction_data["nameDest_token"],
                    prediction,
                    prediction_proba,
                    model_info["model_name"],
                    model_info["version"],
                    model_info["alias"],
                ),
            )

            self.connection.commit()
            logger.info(
                f"Prediction logged: fraud={prediction}, prob={prediction_proba:.3f}"
            )

        except Exception as e:
            logger.error(f"Failed to log prediction: {e}")
            if self.connection:
                self.connection.rollback()


def load_model():
    """Loads the ML model from MLflow."""
    try:
        model_uri = f"models:/{MODEL_NAME}@{MODEL_ALIAS}"
        return mlflow.sklearn.load_model(model_uri)
    except Exception:
        model_version = 1
        model_uri = f"models:/{MODEL_NAME}/{model_version}"
        return mlflow.sklearn.load_model(model_uri)


# Initialize components
model = load_model()
db_logger = DatabaseLogger(DATABASE_URL)
db_logger.connect()

EXPECTED_FEATURES = [
    "step",
    "amount",
    "oldbalanceOrg",
    "newbalanceOrig",
    "oldbalanceDest",
    "newbalanceDest",
    "type",
    "nameOrig_token",
    "nameDest_token",
]


class Transaction(BaseModel):
    step: int
    amount: float
    oldbalanceOrg: float
    newbalanceOrig: float
    oldbalanceDest: float
    newbalanceDest: float
    type: str = Field(..., description="Transaction type", example="CASH_OUT")
    nameOrig_token: int
    nameDest_token: int


class PredictionResponse(BaseModel):
    prediction: int
    probability: float
    risk_level: str
    timestamp: str
    model_info: dict


@app.get("/")
def health_check():
    """Health check endpoint."""
    return {
        "status": "ok",
        "model": MODEL_NAME,
        "alias": MODEL_ALIAS,
        "database_connected": db_logger.connection is not None,
    }


@app.post("/predict", response_model=PredictionResponse)
def predict(transaction: Transaction):
    """Predicts fraud with enhanced response and logging."""

    # Prepare input data
    input_dict = transaction.model_dump()
    df = pd.DataFrame([input_dict])

    # One-hot encode 'type'
    type_values = ["CASH_IN", "CASH_OUT", "DEBIT", "PAYMENT", "TRANSFER"]
    for t in type_values:
        df[f"type__{t}"] = (df["type"] == t).astype(int)
    df = df.drop(columns=["type"])

    # Reorder columns
    ordered_cols = [
        "step",
        "amount",
        "oldbalanceOrg",
        "newbalanceOrig",
        "oldbalanceDest",
        "newbalanceDest",
        "type__CASH_IN",
        "type__CASH_OUT",
        "type__DEBIT",
        "type__PAYMENT",
        "type__TRANSFER",
        "nameOrig_token",
        "nameDest_token",
    ]
    df = df[ordered_cols]

    # Make prediction
    prediction = model.predict(df)[0]
    prediction_proba = model.predict_proba(df)[0]
    fraud_probability = prediction_proba[1]

    # Determine risk level
    if fraud_probability >= 0.8:
        risk_level = "HIGH"
    elif fraud_probability >= 0.5:
        risk_level = "MEDIUM"
    else:
        risk_level = "LOW"

    # Get model info
    try:
        client = MlflowClient()
        model_version_details = client.get_model_version_by_alias(
            name=MODEL_NAME, alias=MODEL_ALIAS
        )
        model_info = {
            "model_name": model_version_details.name,
            "version": model_version_details.version,
            "alias": MODEL_ALIAS,
        }
    except Exception:
        model_info = {"model_name": MODEL_NAME, "version": "1", "alias": MODEL_ALIAS}

    # Log to database
    db_logger.log_prediction(
        transaction_data=input_dict,
        prediction=int(prediction),
        prediction_proba=fraud_probability,
        model_info=model_info,
    )

    return PredictionResponse(
        prediction=int(prediction),
        probability=round(fraud_probability, 4),
        risk_level=risk_level,
        timestamp=datetime.now().isoformat(),
        model_info=model_info,
    )


# Keep your existing endpoints
@app.get("/model-info")
def get_model_info():
    """Returns metadata about the currently loaded ML model."""
    client = MlflowClient()
    model_version_details = client.get_model_version_by_alias(
        name=MODEL_NAME, alias=MODEL_ALIAS
    )
    return {
        "model_name": model_version_details.name,
        "version": model_version_details.version,
        "alias": MODEL_ALIAS,
        "run_id": model_version_details.run_id,
        "status": model_version_details.status,
        "creation_timestamp": model_version_details.creation_timestamp,
        "current_stage": model_version_details.current_stage,
        "source": model_version_details.source,
    }


@app.get("/metrics")
def get_model_metrics():
    """Returns metrics and parameters for the current model run."""
    client = MlflowClient()
    model_version_details = client.get_model_version_by_alias(
        name=MODEL_NAME, alias=MODEL_ALIAS
    )
    run_id = model_version_details.run_id
    run = client.get_run(run_id)
    return {
        "run_id": run_id,
        "metrics": run.data.metrics,
        "params": run.data.params,
    }


@app.get("/feature-info")
def feature_info():
    """Returns information about the model's input features."""
    return {
        "expected_features": EXPECTED_FEATURES,
        "type_dropdown_values": ["CASH_IN", "CASH_OUT", "DEBIT", "PAYMENT", "TRANSFER"],
        "description": "PaySim transaction features. 'type' should be selected from the dropdown.",
        "example": {
            "step": 1,
            "amount": 1000.0,
            "oldbalanceOrg": 5000.0,
            "newbalanceOrig": 4000.0,
            "oldbalanceDest": 0.0,
            "newbalanceDest": 1000.0,
            "type": "CASH_OUT",
            "nameOrig_token": 123,
            "nameDest_token": 456,
        },
    }


@app.get("/monitoring/stats")
def get_monitoring_stats():
    """Get basic monitoring statistics."""
    if not db_logger.connection:
        return {"error": "Database not available"}

    try:
        cursor = db_logger.connection.cursor(cursor_factory=RealDictCursor)

        cursor.execute(
            """
            SELECT COUNT(*) as total_predictions,
                   AVG(prediction) as fraud_rate,
                   AVG(prediction_probability) as avg_fraud_prob
            FROM predictions 
            WHERE timestamp >= NOW() - INTERVAL '24 hours'
        """
        )

        stats = cursor.fetchone()

        return {
            "last_24h_predictions": stats["total_predictions"],
            "fraud_rate": round(stats["fraud_rate"], 4) if stats["fraud_rate"] else 0,
            "avg_fraud_probability": (
                round(stats["avg_fraud_prob"], 4) if stats["avg_fraud_prob"] else 0
            ),
        }

    except Exception as e:
        logger.error(f"Failed to get monitoring stats: {e}")
        return {"error": "Failed to get stats"}
